<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="description" content="View of Algorithms">
<meta name="keywords" content="Algorithms, Sorting, Merge">
<meta name="author" content="Adrian T. Visarra">
<meta name="algorithm" content="since javascript has no delay, it is impossible to use multi-branch recursive call using setTimeout for delay.
so I just solve first using merge sort and each move is saved in an array. after the actual solution, we will animate the solution using
our stored moves. also, before we started, we created a copy of the actual array in order to be used for the animation">
<title>Merge Sort</title>
<script>


//==============================================
var ELEMENTSIZE = 400;
var DELAY = 10;
//==============================================


var debug_board;
var canvas_board;
var array_items = [];
//will be used for animation of the algorithm
var array_items_animated = [];
//we store the sorting moves so that we can use it for animation later after the actual
//array_items are solved
var array_items_moves = [];
function debug(text){
	var li = document.createElement("li");
	var textnode = document.createTextNode(text);
	li.appendChild(textnode);
	debug_board.insertBefore(li, debug_board.firstChild);
}
function getMaxItem(i, len){
	if(len<=0){
		return 0;
	}else if(len==1){
		return array_items[i];
	}else if(len==2){
		if(array_items[i]>array_items[i+1]){
			return array_items[i];
		}else{
			return array_items[i+1];
		}
	}else{
		var fhalf = Math.ceil(len/2);
		var shalf = len - fhalf;
		var fmax = getMaxItem(i, fhalf);
		var smax = getMaxItem(i+fhalf, shalf);
		if(fmax > smax){
			return fmax;
		}else{
			return smax;
		}
	}	
}
var currentFromIndex=-1;
var currentToIndex=-1;
function draw(){
	var ctx = canvas_board.getContext("2d");
	ctx.clearRect(0, 0, canvas_board.width, canvas_board.height);
	var max_item = getMaxItem(0, array_items_animated.length);
	var box_width = canvas_board.width;
	var box_height = canvas_board.height;
	var element_width = 0;
	var element_height = 0;	
	var i = 0;
	for(i=0;i<array_items_animated.length;i++){
		element_width = box_width / array_items_animated.length;
		element_height = Math.floor((array_items_animated[i]/max_item) * box_height);
		ctx.beginPath();
		var width_offset = Math.floor(element_width/2);
		var height_offset = box_height - element_height;
		ctx.moveTo(i*element_width+width_offset, height_offset);
		if(i==currentFromIndex || i==currentToIndex){
			ctx.strokeStyle = '#FF0000';
		}else{
			ctx.strokeStyle = '#91e600';
		}
		ctx.lineWidth = element_width - 1;
		ctx.lineTo(i*element_width+width_offset, element_height + height_offset);
		ctx.stroke();
	}
}
//space complexity is n/2. free space to be used during merging
var left_array_items = [];
//we simulate a static array with size half of the element size in javascript
left_array_items[Math.ceil(ELEMENTSIZE/2 - 1)]=0;
function merge(fhalfIndex, fhalfLen, shalfIndex, shalfLen){
	var tmpIndex = fhalfIndex;
	var i = fhalfIndex;
	var j = shalfIndex;	
	//copy only the elements equivalent to the left element size
	while(tmpIndex<(fhalfIndex+fhalfLen)){
		if(array_items[i]<=array_items[j] || j==(shalfIndex+shalfLen)){
			left_array_items[tmpIndex] = array_items[i];
			array_items_moves.push({'fromIndex':i, 'value':array_items[i], 'toIndex':tmpIndex});
			i++;
		}else{
			left_array_items[tmpIndex] = array_items[j];			
			array_items_moves.push({'fromIndex':j, 'value':array_items[j], 'toIndex':tmpIndex});
			j++;
		}
		tmpIndex++;
	}
	//fill the right half
	tmpIndex = shalfIndex;
	while(i<(fhalfIndex+fhalfLen)){
		if(array_items[i]<=array_items[j] || j==(shalfIndex+shalfLen)){
			array_items[tmpIndex] = array_items[i];
			array_items_moves.push({'fromIndex':i, 'value':array_items[i], 'toIndex':tmpIndex});
			i++;
		}else{
			array_items[tmpIndex] = array_items[j];
			array_items_moves.push({'fromIndex':j, 'value':array_items[j], 'toIndex':tmpIndex});
			j++;
		}		
		tmpIndex++;
	}
	//fill the left half
	tmpIndex = fhalfIndex;
	while(tmpIndex<(fhalfIndex+fhalfLen)){
		array_items[tmpIndex] = left_array_items[tmpIndex];
		tmpIndex++;
	}
}
function mergeSort(i, len){	
	if(len<=1){
		return;
	}else{		
		var fhalf = Math.ceil(len/2);
		var shalf = len - fhalf;	
		mergeSort(i, fhalf);
		mergeSort(i + fhalf, shalf);
		merge(i, fhalf, i+fhalf, shalf);		
	}
}
var counter;
var loopLimit;
var loopDelay;
function looper(){
	setTimeout(function(){
		//if one element only, we will not go inside here
		if(counter<loopLimit){			
			//body======			
			currentFromIndex = array_items_moves[counter].fromIndex;
			currentToIndex = array_items_moves[counter].toIndex;
			array_items_animated[currentToIndex] = array_items_moves[counter].value;
			counter++;
			draw();
			//body======
			if(counter<loopLimit){
				looper();
			}else{
				onDone();
			}
		}else{
			onDone();
		}
	}, loopDelay);
}
function mergeSortAnimated(){
	counter = 0;
	loopLimit = array_items_moves.length;
	loopDelay = DELAY;
	
	currentFromIndex = array_items_moves[counter].fromIndex;
	currentToIndex = array_items_moves[counter].toIndex;
	array_items_animated[currentToIndex] = array_items_moves[counter].value;
	counter++;
	draw();
			
	looper();
}
function generateInput(size){
	var tmparray = [];
	for(var i=1;i<=size;i++){
		tmparray.push(i);
	}
	var randomindex=Math.floor((Math.random() * size));
	for(var i=0;i<size;i++){
		while(tmparray[randomindex] == -1){
			randomindex = Math.floor((Math.random() * size));
		}
		array_items.push(tmparray[randomindex]);
		array_items_animated.push(tmparray[randomindex]);
		tmparray[randomindex] = -1;
	}
}
function resizeEvent(){
	var remainder = window.innerWidth%(array_items.length+1);
	var factor = Math.floor(window.innerWidth/(array_items.length+1));
	canvas_board.setAttribute('width', window.innerWidth-remainder-factor);//right margin
	canvas_board.setAttribute('height', window.innerHeight-100);//bottom margin
	draw();
}
function onDone(){
	currentFromIndex = -1;
	currentToIndex = -1;
	draw();
	debug("--DONE--");
}
function run(){	
	debug_board = document.getElementById("debugger");
	canvas_board = document.getElementById("board");	
	generateInput(ELEMENTSIZE);
	resizeEvent();
	window.onresize=resizeEvent;
	mergeSort(0,ELEMENTSIZE);
	mergeSortAnimated();
	draw();
}
window.onload = run;
</script>
<style>
body{
	background-color: black;
}
#board{
	border: 1px solid #CCCCCC;
	background-color: black;
}
</style>
</head>
<body text="white">
<p>Merge Sort Algorithm</p>
<canvas id="board"></canvas>
<div id="debugger"></div>
</body>
</html>